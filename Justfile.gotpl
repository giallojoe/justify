# ---------- Standard Justfile (portable build/run/debug) ----------
set shell := ["bash", "-eu", "-o", "pipefail", "-c"]
set dotenv-load

# --- build uses defaults per stack (no custom out dir) ---
build:
	@([ -f Cargo.toml ] && cargo build) || true
	@([ -f go.mod ] || ls *.go >/dev/null 2>&1) && go build ./... || true
	@([ -f CMakeLists.txt ] && { \
      BDIR=""; \
      for d in {{- range .CMakeDirs }}"{{.}}" {{- end }}; do \
        if [ -z "$$BDIR" ] && [ -d "$$d" ]; then BDIR="$$d"; fi; \
      done; \
      [ -z "$$BDIR" ] && BDIR="build"; \
      mkdir -p "$$BDIR"; \
      cmake -S . -B "$$BDIR" && cmake --build "$$BDIR"; \
    }) || true
	@([ -f Makefile ] && make) || true
	@([ -f package.json ] && (npm run build || pnpm build || yarn build || true)) || true

# ---- discovery: print the program path (or 'attach:node') ----
program:
	@bash -eu -o pipefail -c '
# Rust
if [ -f Cargo.toml ]; then
  BIN="${CARGO_BIN:-{{ .CargoBinGuess }}}"
  if [ -x "target/debug/$$BIN" ]; then echo "target/debug/$$BIN"; exit 0; fi
  if [ -d target/debug ]; then
    P=$$(find target/debug -maxdepth 1 -type f -perm -111 -printf "%T@ %p\n" 2>/dev/null | sort -nr | head -n1 | cut -d" " -f2-)
    [ -n "$$P" ] && { echo "$$P"; exit 0; }
  fi
fi

# Go
if [ -f go.mod ] || ls *.go >/dev/null 2>&1; then
  NAME=$$(go list -f '{{"{{"}}.Name{{"}}"}}' 2>/dev/null || true)
  if [ "$$NAME" = main ]; then
    MODBASE=$$(basename "$$(go list -m -f '{{"{{"}}.Path{{"}}"}}' 2>/dev/null || echo "$$PWD")")
    for c in "$$MODBASE" "$$(basename "$$PWD")" {{- range .GoExeCandidates }} "{{ . }}" {{- end }}; do
      [ -x "./$$c" ] && { echo "./$$c"; exit 0; }
    done
    P=$$(find . -maxdepth 1 -type f -perm -111 -printf "%T@ %p\n" 2>/dev/null | sort -nr | head -n1 | cut -d" " -f2-)
    [ -n "$$P" ] && { echo "$$P"; exit 0; }
  fi
fi

# C/C++ (CMake build dirs)
for dir in {{- range .CMakeDirs }} "{{ . }}" {{- end }}; do
  if [ -d "$$dir" ]; then
    for exe in {{- range .CppExeCandidates }} "$$dir/{{ . }}" {{- end }}; do
      [ -x "$$exe" ] && { echo "$$exe"; exit 0; }
    done
    P=$$(find "$$dir" -type f -perm -111 -printf "%T@ %p\n" 2>/dev/null | sort -nr | head -n1 | cut -d" " -f2-)
    [ -n "$$P" ] && { echo "$$P"; exit 0; }
  fi
done

# C/C++ (Makefile fallbacks)
if [ -f Makefile ]; then
  for exe in {{- range .MakeExeCandidates }} "./{{ . }}" {{- end }}; do
    [ -x "$$exe" ] && { echo "$$exe"; exit 0; }
  done
fi

# Node
if [ -f package.json ]; then
  P=$$(node -e "try{let p=require('./package.json');console.log(p.main||'')}catch{process.exit(0)}" 2>/dev/null || true)
  [ -n "$$P" ] && [ -f "$$P" ] && { echo "$$P"; exit 0; }
  for f in {{- range .NodeEntries }} "{{ . }}" {{- end }}; do
    [ -f "$$f" ] && { echo "$$f"; exit 0; }
  done
  {{- if .AttachOnDev }}
  if npm pkg get scripts.dev >/dev/null 2>&1; then echo attach:node; exit 0; fi
  {{- end }}
fi

echo "No program found. Run '\''just build'\''." 1>&2; exit 1
'

# ---- kind: rust|go|cpp|node|attach|unknown ----
program-kind:
	@P="$$(just -q program || true)"; \
	if [ "$${P#attach:}" != "$$P" ]; then echo attach; \
	elif [[ "$$P" == target/debug/* ]]; then echo rust; \
	elif [[ "$$P" == ./* ]] && file "$$P" 2>/dev/null | grep -qi "go build"; then echo go; \
	elif file "$$P" 2>/dev/null | grep -qiE "ELF|Mach-O|PE32"; then echo cpp; \
	elif [[ "$$P" == *.mjs || "$$P" == *.cjs || "$$P" == *.js || "$$P" == .next/* || "$$P" == dist/* || "$$P" == build/* ]]; then echo node; \
	else echo unknown; fi

# ---- editor helper: env file with PROGRAM / PROGRAM_KIND ----
write-program-env:
	@mkdir -p .vscode
	@P="$$(just -q program)"; K="$$(just -q program-kind)"; \
	printf "PROGRAM=%s\nPROGRAM_KIND=%s\n" "$$P" "$$K" > .vscode/.program.env; \
	echo "Wrote .vscode/.program.env"

# ---- convenience run (uses discovery) ----
run: build
	@P="$$(just -q program)"; \
	if [[ "$$P" == attach:* ]]; then echo "Dev server detected. Start it with --inspect and attach your debugger."; exit 0; fi; \
	exec "$$P"
